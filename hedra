#!/usr/bin/env python3
"""
Hedra API Client - Command-line interface for the Hedra API
"""

import requests
import time
import argparse
import os
import sys
import json
import subprocess
from pathlib import Path
import tempfile

# Import face selection module (optional dependency)
try:
    from face_selector import select_face, preview_faces
    FACE_SELECTION_AVAILABLE = True
except ImportError:
    FACE_SELECTION_AVAILABLE = False

# Constants
BASE_URL = "https://api.hedra.com/web-app"
CONFIG_FILE = os.path.expanduser("~/.hedra.conf")
ASPECT_RATIO_OPTIONS = ["1:1", "16:9", "9:16"]
ASSETS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "assets")
DEFAULT_AI_MODEL_ID = "d1dd37a3-e39a-4854-a298-6510289f9cf2"

def load_config():
    """Load configuration from file or environment"""
    config = {
        "api_key": os.environ.get("HEDRA_API_KEY", ""),
        "base_url": os.environ.get("HEDRA_BASE_URL", BASE_URL),
        "default_aspect_ratio": "1:1",
        "default_output_dir": "outputs",
        "assets_dir": ASSETS_DIR,
        "default_ai_model_id": DEFAULT_AI_MODEL_ID
    }
    
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                for line in f:
                    if '=' in line:
                        key, value = line.strip().split('=', 1)
                        config[key.strip()] = value.strip()
        except Exception:
            pass
    
    return config

def save_config(config):
    """Save configuration to file"""
    os.makedirs(os.path.dirname(CONFIG_FILE), exist_ok=True)
    with open(CONFIG_FILE, 'w') as f:
        for key, value in config.items():
            f.write(f"{key}={value}\n")
    print(f"‚úÖ Configuration saved to {CONFIG_FILE}")

def get_api_headers(config):
    """Get API headers with API key"""
    return {"X-API-Key": config["api_key"]}

def api_request(config, method, path, **kwargs):
    """Make an API request with error handling"""
    url = f"{config['base_url']}{path}"
    headers = get_api_headers(config)
    
    if "headers" in kwargs:
        headers.update(kwargs.pop("headers"))
    
    # Remove the raise_for_status parameter if present
    if "raise_for_status" in kwargs:
        should_raise = kwargs.pop("raise_for_status")
    else:
        should_raise = True
    
    try:
        response = getattr(requests, method.lower())(url, headers=headers, **kwargs)
        
        # Manually raise for status if needed
        if should_raise:
            response.raise_for_status()
            
        return response.json() if response.content else None
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 401:
            print("‚ùå Authentication failed. Check your API key.")
        elif e.response.status_code == 404:
            print(f"‚ùå Resource not found: {path}")
        elif e.response.status_code == 422:
            print(f"‚ùå Validation error: {e.response.text}")
        elif e.response.status_code == 504:
            print("‚ö†Ô∏è Gateway timeout, you may want to retry")
        else:
            print(f"‚ùå HTTP Error: {e}")
        if should_raise:
            sys.exit(1)
        return None
    except Exception as e:
        print(f"‚ùå Error: {e}")
        if should_raise:
            sys.exit(1)
        return None

def get_voices(config):
    """Get available voices"""
    response = api_request(config, "GET", "/public/assets", params={"type": "voice"})
    return response

def find_local_voice_file(voice_name):
    """Find a local voice file in the assets directory"""
    if not os.path.exists(ASSETS_DIR):
        return None
    
    # Try exact match first
    for ext in [".mp3", ".wav"]:
        path = os.path.join(ASSETS_DIR, f"{voice_name}{ext}")
        if os.path.exists(path):
            return path
    
    # Try case-insensitive match
    for file in os.listdir(ASSETS_DIR):
        file_lower = file.lower()
        name_lower = voice_name.lower()
        
        # Strip extension for comparison
        file_base = os.path.splitext(file_lower)[0]
        
        if name_lower == file_base:
            return os.path.join(ASSETS_DIR, file)
    
    return None

def list_local_voices():
    """List voice files found in the assets directory"""
    if not os.path.exists(ASSETS_DIR):
        return []
    
    voice_files = []
    for file in os.listdir(ASSETS_DIR):
        if file.lower().endswith(('.mp3', '.wav')):
            voice_files.append(file)
    
    return voice_files

def print_available_voices(config):
    """Display available voices"""
    # Get voices from API
    voices = get_voices(config)
    
    # Get local voice files
    local_voice_files = list_local_voices()
    local_voice_names = [os.path.splitext(f)[0] for f in local_voice_files]
    
    print("\nAvailable Voices:")
    print("-" * 80)
    print(f"{'NAME':<30} {'ID':<30} {'SERVICE':<10} {'PREMIUM':<8} {'LOCAL'}")
    print("-" * 80)
    
    for v in voices:
        name = v.get("name", "(Unnamed)")
        vid = v["id"]
        service = v.get("service", "")
        premium = "‚úì" if v.get("premium", False) else ""
        local = "‚úì" if name in local_voice_names or any(name.lower() in file.lower() for file in local_voice_files) else ""
        print(f"{name:<30} {vid:<30} {service:<10} {premium:<8} {local}")
    
    print("-" * 80)
    print("\nTo preview a voice, use: hedra voice preview <voice_id_or_name>")
    
    if local_voice_files:
        print("\nLocal voice files found in assets directory:")
        for file in sorted(local_voice_files):
            print(f"  - {file}")

def play_voice_preview(config, voice_id_or_name):
    """Play a preview of a voice (from local file if available, otherwise from API)"""
    # First check if we have a local file for this voice
    local_file = find_local_voice_file(voice_id_or_name)
    
    # If no local file with that name, check if it's a voice ID and try to find by name
    if not local_file:
        voices = get_voices(config)
        for voice in voices:
            if voice["id"] == voice_id_or_name:
                # Found a matching voice ID, try to find local file with the voice name
                if voice.get("name"):
                    local_file = find_local_voice_file(voice.get("name"))
                break
    
    # If we found a local file, play it
    if local_file:
        print(f"‚ñ∂Ô∏è Playing local preview from {local_file}...")
        
        try:
            # Play with appropriate player depending on OS
            if sys.platform == "darwin":  # macOS
                subprocess.run(["afplay", local_file], check=True)
            elif sys.platform.startswith("linux"):
                players = ["ffplay", "mpg123", "mplayer"]
                for player in players:
                    try:
                        if player == "ffplay":
                            subprocess.run([player, "-autoexit", "-nodisp", local_file], 
                                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                        else:
                            subprocess.run([player, local_file], 
                                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                        break
                    except FileNotFoundError:
                        continue
                else:
                    print("‚ùå No supported audio player found. Please install ffplay, mpg123, or mplayer.")
            elif sys.platform == "win32":  # Windows
                subprocess.run(["start", local_file], shell=True)
            else:
                print(f"‚ùå Unsupported platform: {sys.platform}")
            return
        except Exception as e:
            print(f"‚ùå Error playing local file: {e}")
            # Continue to try online preview as fallback
    
    # If no local file or failed to play it, try to get from API
    voices = get_voices(config)
    
    found_voice = None
    for voice in voices:
        if voice["id"] == voice_id_or_name or (voice.get("name") and voice_id_or_name.lower() in voice.get("name", "").lower()):
            found_voice = voice
            break
    
    if not found_voice:
        print(f"‚ùå Voice '{voice_id_or_name}' not found locally or in API")
        return
    
    preview_url = found_voice.get("preview_url")
    if not preview_url:
        print(f"‚ùå No preview available for voice '{found_voice.get('name', voice_id_or_name)}'")
        return
    
    print(f"‚ñ∂Ô∏è Playing online preview for '{found_voice.get('name', voice_id_or_name)}'...")
    
    try:
        with tempfile.NamedTemporaryFile(suffix=".mp3") as temp:
            # Download the file
            r = requests.get(preview_url)
            r.raise_for_status()
            temp.write(r.content)
            temp.flush()
            
            # Play with appropriate player depending on OS
            if sys.platform == "darwin":  # macOS
                subprocess.run(["afplay", temp.name], check=True)
            elif sys.platform.startswith("linux"):
                players = ["ffplay", "mpg123", "mplayer"]
                for player in players:
                    try:
                        if player == "ffplay":
                            subprocess.run([player, "-autoexit", "-nodisp", temp.name], 
                                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                        else:
                            subprocess.run([player, temp.name], 
                                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                        break
                    except FileNotFoundError:
                        continue
                else:
                    print("‚ùå No supported audio player found. Please install ffplay, mpg123, or mplayer.")
            elif sys.platform == "win32":  # Windows
                subprocess.run(["start", temp.name], shell=True)
            else:
                print(f"‚ùå Unsupported platform: {sys.platform}")
    except Exception as e:
        print(f"‚ùå Error playing preview: {e}")

def resolve_voice_id(config, voice_name=None, voice_id=None):
    """Resolve a voice ID from a name or ID"""
    voices = get_voices(config)
    
    if voice_id:
        # Verify the voice_id exists
        for voice in voices:
            if voice["id"] == voice_id:
                return voice_id
        print(f"‚ùå Voice ID '{voice_id}' not found")
        sys.exit(1)
        
    if voice_name:
        for voice in voices:
            if voice.get("name") and voice_name.lower() in voice.get("name", "").lower():
                return voice["id"]
        print(f"‚ùå Voice name '{voice_name}' not found")
        sys.exit(1)
    
    # Default to first voice if none specified
    return voices[0]["id"]

def upload_image(config, image_path):
    """Upload an image file"""
    if not os.path.exists(image_path):
        print(f"‚ùå Image file not found: {image_path}")
        sys.exit(1)
        
    print(f"üì§ Uploading image {image_path}...")
    
    # First create the asset
    filename = os.path.basename(image_path)
    create_response = api_request(
        config,
        "POST",
        "/public/assets",
        json={
            "name": filename,
            "type": "image"
        }
    )
    asset_id = create_response['id']
    
    # Then upload the file
    with open(image_path, 'rb') as f:
        api_request(
            config, 
            "POST",
            f"/public/assets/{asset_id}/upload",
            files={'file': f}
        )
    
    return asset_id

def upload_audio(config, audio_path):
    """Upload an audio file"""
    if not os.path.exists(audio_path):
        print(f"‚ùå Audio file not found: {audio_path}")
        sys.exit(1)
        
    print(f"üì§ Uploading audio {audio_path}...")
    
    # First create the asset
    filename = os.path.basename(audio_path)
    create_response = api_request(
        config,
        "POST",
        "/public/assets",
        json={
            "name": filename,
            "type": "audio"
        }
    )
    asset_id = create_response['id']
    
    # Then upload the file
    with open(audio_path, 'rb') as f:
        api_request(
            config, 
            "POST",
            f"/public/assets/{asset_id}/upload",
            files={'file': f}
        )
    
    return asset_id

def generate_audio_payload(config, args, voice_id):
    """Generate the audio part of the payload"""
    if args.audio_file:
        audio_id = upload_audio(config, args.audio_file)
        return {"audio_id": audio_id}
    elif args.text:
        # For TTS, we need to generate the audio first
        tts_response = api_request(
            config,
            "POST",
            "/public/generations",
            json={
                "type": "text_to_speech",
                "voice_id": voice_id,
                "text": args.text
            }
        )
        # Wait for TTS completion
        tts_result = wait_for_completion(config, tts_response['id'])
        return {"audio_id": tts_response['asset_id']}
    else:
        print("‚ùå You must specify either --text or --audio-file")
        sys.exit(1)

def generate_avatar_payload(config, args, voice_id):
    """Generate the complete avatar generation payload"""
    payload = {
        "type": "video",
        "ai_model_id": getattr(args, 'ai_model_id', config.get('default_ai_model_id', DEFAULT_AI_MODEL_ID)),
        "generated_video_inputs": {
            "text_prompt": getattr(args, 'animation_prompt', 'A person speaking naturally'),
            "aspect_ratio": args.aspect_ratio,
            "duration_ms": getattr(args, 'duration_ms', 0)
        }
    }
    
    # Add audio
    audio_info = generate_audio_payload(config, args, voice_id)
    payload.update(audio_info)

    # Add image
    if args.img:
        payload["start_keyframe_id"] = upload_image(config, args.img)
    elif args.img_prompt:
        # Generate image first
        img_response = api_request(
            config,
            "POST",
            "/public/generations",
            json={
                "type": "image",
                "text_prompt": args.img_prompt,
                "aspect_ratio": args.aspect_ratio,
                "resolution": getattr(args, 'resolution', "1080p"),
                "ai_model_id": getattr(args, 'ai_model_id', config.get('default_ai_model_id', DEFAULT_AI_MODEL_ID))
            }
        )
        # Wait for image completion
        img_result = wait_for_completion(config, img_response['id'])
        payload["start_keyframe_id"] = img_response['asset_id']
    else:
        print("‚ùå You must provide --img or --img-prompt")
        sys.exit(1)

    # Add bounding box target if specified
    if hasattr(args, 'bounding_box') and args.bounding_box:
        try:
            # Parse bounding box coordinates
            coords = [float(x.strip()) for x in args.bounding_box.split(',')]
            if len(coords) != 2:
                raise ValueError("Bounding box must have exactly 2 coordinates")
            if not all(0 <= coord <= 1 for coord in coords):
                raise ValueError("Bounding box coordinates must be between 0 and 1")
            payload["generated_video_inputs"]["bounding_box_target"] = coords
        except ValueError as e:
            print(f"‚ùå Invalid bounding box format: {e}")
            sys.exit(1)

    return payload

def wait_for_completion(config, generation_id, poll_interval=5, max_retries=100):
    """Wait for a job to complete with a progress indicator"""
    print("‚è≥ Waiting for job completion...")
    
    for i in range(max_retries):
        try:
            # Use the new generations status endpoint
            response = api_request(config, "GET", f"/public/generations/{generation_id}/status", raise_for_status=False)
            if not response:
                time.sleep(poll_interval)
                continue
                
            status = response.get('status', 'Unknown')
            progress = response.get('progress', 0) or 0
            
            # Create a simple progress bar
            bar_length = 30
            filled_length = int(bar_length * progress * 100)  # progress is 0-1 now
            bar = '‚ñà' * filled_length + '‚ñë' * (bar_length - filled_length)
            
            # Calculate elapsed time
            elapsed = i * poll_interval
            mins = elapsed // 60
            secs = elapsed % 60
            
            # Print status line
            print(f"\r[{bar}] {progress*100:3.0f}% | Status: {status} | Time: {mins:02d}:{secs:02d}", end='')
            
            if status == "complete":
                print("\n‚úÖ Generation completed!")
                return response.get("url")
            elif status == "error":
                error_msg = response.get("error_message", "Unknown error")
                print(f"\n‚ùå Generation failed: {error_msg}")
                sys.exit(1)
        except Exception as e:
            print(f"\n‚ö†Ô∏è Error checking status: {e}")
        
        time.sleep(poll_interval)
    
    print("\n‚ùå Max retries reached without completion")
    sys.exit(1)

def download_file(url, out_path):
    """Download a file"""
    try:
        print(f"üì• Downloading to {out_path}...")
        r = requests.get(url, stream=True)
        r.raise_for_status()
        
        # Ensure directory exists
        os.makedirs(os.path.dirname(os.path.abspath(out_path)), exist_ok=True)
        
        # Get total size if available
        total_size = int(r.headers.get('content-length', 0))
        
        with open(out_path, 'wb') as f:
            if total_size > 0:
                # Show progress if size is known
                downloaded = 0
                for chunk in r.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        percent = downloaded / total_size * 100
                        bar_length = 30
                        filled_length = int(bar_length * percent / 100)
                        bar = '‚ñà' * filled_length + '‚ñë' * (bar_length - filled_length)
                        print(f"\r[{bar}] {percent:3.1f}%", end='')
                print()  # New line after progress
            else:
                # Just download without progress if size is unknown
                for chunk in r.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
        
        print(f"‚úÖ Saved to {out_path}")
        return True
    except Exception as e:
        print(f"‚ùå Download failed: {e}")
        return False

def list_projects(config, limit=10):
    """List recent generations"""
    response = api_request(config, "GET", "/public/generations", params={"paging_params": {"limit": limit, "offset": 0}})
    generations = response.get("data", [])
    
    if not generations:
        print("No generations found")
        return
    
    print("\nRecent Generations:")
    print("-" * 100)
    print(f"{'ID':<36} {'CREATED':<20} {'STATUS':<10} {'TYPE':<15} {'PROGRESS':<10}")
    print("-" * 100)
    
    for g in generations:
        gen_id = g.get("id", "")
        created_at = g.get("created_at", "").replace("T", " ").replace("Z", "")[:19] if g.get("created_at") else ""
        status = g.get("status", "")
        gen_type = g.get("type", "")
        progress = g.get("progress", 0) * 100 if g.get("progress") else 0
        
        print(f"{gen_id:<36} {created_at:<20} {status:<10} {gen_type:<15} {progress:3.0f}%")
    
    print("-" * 100)

def get_project(config, generation_id):
    """Get and display a generation"""
    response = api_request(config, "GET", f"/public/generations/{generation_id}/status")
    
    if not response:
        return
    
    print("\nGeneration Details:")
    print("-" * 80)
    print(f"Generation ID:   {response.get('id', 'N/A')}")
    print(f"Asset ID:        {response.get('asset_id', 'N/A')}")
    print(f"Created:         {response.get('created_at', 'N/A').replace('T', ' ').replace('Z', '')[:19] if response.get('created_at') else 'N/A'}")
    print(f"Status:          {response.get('status', 'N/A')}")
    print(f"Progress:        {(response.get('progress', 0) or 0) * 100:.1f}%")
    print(f"Type:            {response.get('type', 'N/A')}")
    print(f"URL:             {response.get('url', 'N/A')}")
    print(f"Error:           {response.get('error_message', 'None')}")
    print("-" * 80)

def delete_project(config, project_id):
    """Delete a project"""
    print(f"üóëÔ∏è Deleting project {project_id}...")
    api_request(config, "DELETE", f"/v1/projects/{project_id}")
    print(f"‚úÖ Project {project_id} deleted")

def share_project(config, project_id, share_state=True):
    """Share or unshare a project"""
    action = "Sharing" if share_state else "Unsharing"
    print(f"üîÑ {action} project {project_id}...")
    api_request(config, "POST", f"/v1/projects/{project_id}/sharing", params={"shared": share_state})
    
    status = "shared" if share_state else "unshared"
    print(f"‚úÖ Project {project_id} {status}")

def interactive_mode(config):
    """Run interactive mode with a simplified interface"""
    print("üé¨ Hedra Interactive Character Generation")
    
    try:
        # Get voices
        voices = get_voices(config)
        
        # Choose image source
        print("\nüì∏ Image Source:")
        print("  [1] Upload an image")
        print("  [2] Generate from a prompt")
        
        img_choice = 0
        while img_choice < 1 or img_choice > 2:
            try:
                img_choice = int(input("Choose an option (number): "))
            except ValueError:
                print("Please enter a valid number")
        
        img = img_prompt = None
        if img_choice == 1:  # Upload
            img = input("Path to image file: ").strip()
            while not os.path.exists(img):
                print("‚ùå File not found")
                img = input("Path to image file (or leave empty to change option): ").strip()
                if not img:
                    return interactive_mode(config)
        else:  # Generate from prompt
            img_prompt = input("Image generation prompt: ").strip()
            while not img_prompt:
                print("‚ùå Prompt cannot be empty")
                img_prompt = input("Image generation prompt: ").strip()
        
        # Get local voice files
        local_voice_files = list_local_voices()
        local_voice_names = [os.path.splitext(f)[0] for f in local_voice_files]
        
        # Choose voice - show top 10 only for simplicity
        print("\nüéôÔ∏è Voice Selection:")
        display_voices = voices[:10]  # Limit to top 10 for simplicity
        
        for i, voice in enumerate(display_voices):
            name = voice.get("name", "Unnamed")
            vid = voice["id"]
            local = " (local)" if name in local_voice_names or any(name.lower() in file.lower() for file in local_voice_files) else ""
            print(f"  [{i+1}] {name}{local} (ID: {vid})")
        
        if len(voices) > 10:
            print(f"  (Showing 10 of {len(voices)} voices. Use 'hedra voice list' to see all.)")
        
        # Select a voice
        voice_idx = -1
        while voice_idx < 0 or voice_idx >= len(display_voices):
            try:
                voice_idx = int(input("Select voice number: ")) - 1
                if voice_idx < 0 or voice_idx >= len(display_voices):
                    print("‚ùå Invalid voice number")
            except ValueError:
                print("‚ùå Please enter a number")
        
        voice_id = display_voices[voice_idx]["id"]
        
        # Get audio source
        print("\nüîä Audio Source:")
        print("  [1] Text to speech")
        print("  [2] Upload audio file")
        
        audio_choice = 0
        while audio_choice < 1 or audio_choice > 2:
            try:
                audio_choice = int(input("Choose an option (number): "))
            except ValueError:
                print("Please enter a valid number")
        
        text = audio_file = None
        if audio_choice == 1:  # TTS
            text = input("Enter text to speak: ").strip()
            while not text:
                print("‚ùå Text cannot be empty")
                text = input("Enter text to speak: ").strip()
        else:  # Upload audio
            audio_file = input("Path to audio file: ").strip()
            while not os.path.exists(audio_file):
                print("‚ùå File not found")
                audio_file = input("Path to audio file (or leave empty to change option): ").strip()
                if not audio_file:
                    return interactive_mode(config)
        
        # Choose aspect ratio
        print("\nüìê Aspect Ratio:")
        for i, ar in enumerate(ASPECT_RATIO_OPTIONS):
            print(f"  [{i+1}] {ar}")
        
        ar_choice = 0
        while ar_choice < 1 or ar_choice > len(ASPECT_RATIO_OPTIONS):
            try:
                ar_choice = int(input("Choose an aspect ratio (number): "))
            except ValueError:
                print("Please enter a valid number")
        
        aspect_ratio = ASPECT_RATIO_OPTIONS[ar_choice-1]
        
        # Optional: seed
        seed_input = input("Enter a seed for reproducibility (optional, press enter to skip): ").strip()
        seed = int(seed_input) if seed_input and seed_input.isdigit() else None
        
        # Output file
        output_dir = config.get("default_output_dir", "outputs")
        os.makedirs(output_dir, exist_ok=True)
        output_file = input(f"Output filename (default: output_{int(time.time())}.mp4): ").strip()
        if not output_file:
            output_file = f"output_{int(time.time())}.mp4"
        
        # If not an absolute path, put in the output dir
        if not os.path.isabs(output_file):
            output_file = os.path.join(output_dir, output_file)
        
        # Confirm settings before proceeding
        print("\nGeneration Settings:")
        settings = [
            f"Image: {'Upload: ' + img if img else 'Generated from prompt: ' + img_prompt}",
            f"Voice: {display_voices[voice_idx].get('name', 'Unknown')} (ID: {voice_id})",
            f"Audio: {'Text: ' + text if text else 'File: ' + audio_file}",
            f"Aspect Ratio: {aspect_ratio}",
            f"Output: {output_file}"
        ]
        
        if seed is not None:
            settings.append(f"Seed: {seed}")
        
        for setting in settings:
            print(f"  - {setting}")
        
        confirm = input("\nProceed with generation? (y/n): ").lower().strip()
        if confirm != 'y':
            print("Generation cancelled")
            return
        
        # Create args object for compatibility with existing functions
        class Args:
            pass
        
        args = Args()
        args.voice_id = voice_id
        args.text = text
        args.audio_file = audio_file
        args.img = img
        args.img_prompt = img_prompt
        args.aspect_ratio = aspect_ratio
        args.animation_prompt = None
        args.seed = seed
        args.output = output_file
        
        # Generate character
        payload = generate_avatar_payload(config, args, voice_id)
        
        print("\nüöÄ Starting generation...")
        response = api_request(config, "POST", "/v1/characters", json=payload)
        job_id = response['jobId']
        
        print(f"Job ID: {job_id}")
        result_url = wait_for_completion(config, job_id)
        
        if result_url:
            download_file(result_url, args.output)
            
            # If we generated from a prompt, also save the avatar image info
            if args.img_prompt:
                # Get the project to find the avatar image URL
                project = api_request(config, "GET", f"/v1/projects/{job_id}")
                avatar_url = project.get("avatarImageUrl")
                
                if avatar_url:
                    avatar_path = args.output.replace('.mp4', '_avatar.jpg')
                    download_file(avatar_url, avatar_path)
        
        return job_id
    
    except KeyboardInterrupt:
        print("\nInteractive mode cancelled")
        return None
    except Exception as e:
        print(f"‚ùå Error in interactive mode: {e}")
        return None

def setup_parser():
    """Setup argument parser with subcommands"""
    parser = argparse.ArgumentParser(
        description="Hedra API Client - Create digital avatars and talking heads",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # List available voices
  hedra voice list
  
  # Preview a voice
  hedra voice preview <voice_id_or_name>
  
  # Generate a character with text-to-speech
  hedra generate --text "Hello, world!" --voice-id <voice_id> --img-prompt "A smiling woman with red hair"
  
  # Generate a character with an uploaded image and audio
  hedra generate --audio-file input.mp3 --img portrait.jpg
  
  # Interactive face selection for multi-person images
  hedra generate --text "Hello!" --img group_photo.jpg --select-face
  
  # Auto-select best face (largest/most prominent)
  hedra generate --text "Hello!" --img photo.jpg --auto-face
  
  # Preview faces in image without generating
  hedra generate --preview-faces --img photo.jpg
  
  # Manual bounding box coordinates
  hedra generate --text "Hello!" --img photo.jpg --bounding-box "0.3,0.4"
  
  # Run in interactive mode
  hedra interactive
  
  # List recent projects
  hedra project list
  
  # Get project details
  hedra project get <project_id>
  """
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # Config command
    config_parser = subparsers.add_parser("config", help="Configure the client")
    config_parser.add_argument("--api-key", help="Set API key")
    config_parser.add_argument("--base-url", help="Set base URL")
    config_parser.add_argument("--default-output-dir", help="Set default output directory")
    config_parser.add_argument("--assets-dir", help="Set assets directory (for local voices)")
    
    # Voice commands
    voice_parser = subparsers.add_parser("voice", help="Voice-related commands")
    voice_subparsers = voice_parser.add_subparsers(dest="voice_command", help="Voice command to run")
    
    voice_list_parser = voice_subparsers.add_parser("list", help="List available voices")
    
    voice_preview_parser = voice_subparsers.add_parser("preview", help="Preview a voice")
    voice_preview_parser.add_argument("voice_id_or_name", help="Voice ID or name to preview")
    
    # Project commands
    project_parser = subparsers.add_parser("project", help="Project management commands")
    project_subparsers = project_parser.add_subparsers(dest="project_command", help="Project command to run")
    
    project_list_parser = project_subparsers.add_parser("list", help="List recent projects")
    project_list_parser.add_argument("--limit", type=int, default=10, help="Maximum number of projects to show")
    
    project_get_parser = project_subparsers.add_parser("get", help="Get project details")
    project_get_parser.add_argument("project_id", help="Project ID")
    
    project_delete_parser = project_subparsers.add_parser("delete", help="Delete a project")
    project_delete_parser.add_argument("project_id", help="Project ID")
    
    project_share_parser = project_subparsers.add_parser("share", help="Share a project")
    project_share_parser.add_argument("project_id", help="Project ID")
    project_share_parser.add_argument("--unshare", action="store_true", help="Unshare instead of share")
    
    project_download_parser = project_subparsers.add_parser("download", help="Download project output")
    project_download_parser.add_argument("project_id", help="Project ID")
    project_download_parser.add_argument("--output", "-o", help="Output file path")
    
    # Generate commands
    generate_parser = subparsers.add_parser("generate", help="Generate a character")
    generate_parser.add_argument("--text", help="Text to convert to speech")
    generate_parser.add_argument("--voice-id", help="Voice ID to use")
    generate_parser.add_argument("--voice-name", help="Voice name to use (alternative to --voice-id)")
    generate_parser.add_argument("--audio-file", help="Audio file to use instead of text-to-speech")
    generate_parser.add_argument("--img", help="Image file to use")
    generate_parser.add_argument("--img-prompt", help="Prompt to generate an image")
    generate_parser.add_argument("--output", "-o", default="output.mp4", help="Output file path")
    generate_parser.add_argument("--poll-interval", type=int, default=5, help="Interval between polls for job status")
    generate_parser.add_argument("--max-retries", type=int, default=100, help="Maximum number of retries for job status")
    generate_parser.add_argument("--aspect-ratio", "--ar", choices=ASPECT_RATIO_OPTIONS, default="1:1", help="Aspect ratio for the output")
    generate_parser.add_argument("--animation-prompt", "--ap", help="Animation prompt to use")
    generate_parser.add_argument("--seed", type=int, help="Seed for image generation")
    generate_parser.add_argument("--bounding-box", "--bb", help="Bounding box coordinates (x,y) for primary speaker position (Character3 only). Values should be between 0 and 1.")
    generate_parser.add_argument("--ai-model-id", help="AI model ID to use for generation")
    generate_parser.add_argument("--duration-ms", type=int, default=0, help="Duration of the video in milliseconds")
    generate_parser.add_argument("--resolution", default="1080p", help="Resolution for the video (e.g. 540p, 1080p, 1440p)")
    
    # Face selection arguments
    generate_parser.add_argument("--select-face", action="store_true", help="Interactive face selection from image")
    generate_parser.add_argument("--auto-face", action="store_true", help="Automatically select best detected face")
    generate_parser.add_argument("--preview-faces", action="store_true", help="Preview detected faces without generating")
    
    # Interactive mode
    interactive_parser = subparsers.add_parser("interactive", help="Run in interactive mode")
    
    return parser

def main():
    """Main entry point"""
    parser = setup_parser()
    
    # If no arguments provided, show help
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(0)
    
    args = parser.parse_args()
    config = load_config()
    
    # Check if API key is set
    if not config.get("api_key") and args.command != "config":
        print("‚ùå API key not set. Use 'hedra config --api-key YOUR_API_KEY' to set it.")
        sys.exit(1)
    
    # Handle config command
    if args.command == "config":
        if args.api_key:
            config["api_key"] = args.api_key
        if args.base_url:
            config["base_url"] = args.base_url
        if args.default_output_dir:
            config["default_output_dir"] = args.default_output_dir
            os.makedirs(args.default_output_dir, exist_ok=True)
        if args.assets_dir:
            config["assets_dir"] = args.assets_dir
        
        save_config(config)
        sys.exit(0)
    
    # Handle voice commands
    elif args.command == "voice":
        if args.voice_command == "list":
            print_available_voices(config)
        elif args.voice_command == "preview":
            play_voice_preview(config, args.voice_id_or_name)
        else:
            print("‚ùå Please specify a voice subcommand")
            sys.exit(1)
    
    # Handle project commands
    elif args.command == "project":
        if args.project_command == "list":
            list_projects(config, args.limit)
        elif args.project_command == "get":
            get_project(config, args.project_id)
        elif args.project_command == "delete":
            delete_project(config, args.project_id)
        elif args.project_command == "share":
            share_project(config, args.project_id, not args.unshare)
        elif args.project_command == "download":
            # Get project first to find the URL
            response = api_request(config, "GET", f"/v1/projects/{args.project_id}")
            url = response.get("videoUrl") or response.get("voiceUrl")
            
            if not url:
                print("‚ùå No URL found in project")
                sys.exit(1)
            
            # Determine output path
            output_path = args.output
            if not output_path:
                output_path = f"project_{args.project_id}.mp4"
            
            download_file(url, output_path)
        else:
            print("‚ùå Please specify a project subcommand")
            sys.exit(1)
    
    # Handle generate command
    elif args.command == "generate":
        # Handle face preview mode
        if args.preview_faces and args.img:
            if FACE_SELECTION_AVAILABLE:
                print("üîç Analyzing faces in image...")
                preview_faces(args.img)
            else:
                print("‚ùå Face selection not available. Install with: pip install opencv-python")
            sys.exit(0)
        
        # Handle face selection
        if (args.select_face or args.auto_face) and args.img:
            if not FACE_SELECTION_AVAILABLE:
                print("‚ùå Face selection not available. Install with: pip install opencv-python")
                print("üí° Use manual --bounding-box x,y coordinates instead")
                sys.exit(1)
            
            try:
                if args.auto_face:
                    print("ü§ñ Auto-detecting best face...")
                    coords = select_face(args.img, mode='auto')
                else:
                    print("üé≠ Interactive face selection...")
                    coords = select_face(args.img, mode='interactive')
                
                if coords:
                    args.bounding_box = f"{coords[0]:.3f},{coords[1]:.3f}"
                    print(f"‚úÖ Face selected: {args.bounding_box}")
                else:
                    print("‚ùå No face selected. Continuing without bounding box.")
                    
            except Exception as e:
                print(f"‚ùå Face selection failed: {e}")
                print("üí° Use manual --bounding-box x,y coordinates instead")
        
        voice_id = resolve_voice_id(config, args.voice_name, args.voice_id)
        payload = generate_avatar_payload(config, args, voice_id)
        
        print("üöÄ Starting generation request...")
        response = api_request(config, "POST", "/public/generations", json=payload)
        job_id = response['id']
        
        print(f"Job ID: {job_id}")
        result_url = wait_for_completion(config, job_id, args.poll_interval, args.max_retries)
        
        if result_url:
            download_file(result_url, args.output)
            
            # If we generated from a prompt, also save the avatar image info
            if args.img_prompt:
                avatar_path = args.output.replace('.mp4', '_avatar.jpg')
                print(f"üì∏ Exporting avatar image metadata to {avatar_path}")
                
                # Try to get the actual image URL from the project
                project = api_request(config, "GET", f"/v1/projects/{job_id}")
                avatar_url = project.get("avatarImageUrl")
                
                if avatar_url:
                    download_file(avatar_url, avatar_path)
                else:
                    # If no URL, just save the prompt
                    with open(avatar_path, 'w') as f:
                        f.write(f"Avatar generated from prompt: '{args.img_prompt}'\n")
                        if args.seed is not None:
                            f.write(f"Seed: {args.seed}\n")
    
    # Handle interactive mode
    elif args.command == "interactive":
        interactive_mode(config)
    
    else:
        print("‚ùå Unknown command. Use --help to see available commands.")
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(130)
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        sys.exit(1)
